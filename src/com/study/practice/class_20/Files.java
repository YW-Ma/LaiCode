package com.study.practice.class_20;

public class Files {
    public static void main(String[] args) {
        String str = "\"2021 春季3班 Practice Class 正式教案\nRequest edit access\n5\n \n \n \nShare\nFileEditViewToolsHelp\nTo enable screen reader support, press ⌘+Option+Z To learn about keyboard shortcuts, press ⌘slash\n上课时间 \n●具体上课日期和时间请看理论课正式教案和LMS \n●Anna老师 anna@laioffer.com \n●Chow老师 chow.laioffer@gmail.com \n \n=======================   Zoom  ===================== \nPlease join my meeting from your computer, tablet or smartphone. \n \n●请使用理论课正式教案的zoom信息 \n \n======================== 答疑 ============================ \nLMS Q&A答疑平台 Link \n========================================================= \n \n上过的课程教案在这里（复习/预习）： \n存档 \n \nCoding Pad \n \n \n《高效能人士的执行4原则》 \n原则1：聚焦最重要目标 \n1.你想做的越多，能做成的越少 \n原则2：关注引领性指标 \n1.滞后性指标：描述你想要改善的方面的指标（结果），比如考试成绩 \na.滞后性指标的问题：太晚了，导致结果的行为已经完成 \n2.引领性指标：对于达成预定目标有着最重要作用行为的指标，比如deep \nwork时间 \na.制定好的引领性指标：第一，它具有预见性；第二，团队成员可以影\n响这些指标。 \n原则3：坚持激励性计分板 \n1.使用可量化的计分方式，可视化的分数会强化动机 \n原则4：建立规律问责制 \n1.用于回顾引领性指标、校正行为 \n2.任何拥有最重要目标的团队召开例会，回顾计分板 \n3.没有团队的情况下，个人也必须要定期（每周）回顾 \n \n优秀团队的实际执行顺序：坚持让自己持续不断地肩负起做好引领性指标的责\n任，从而驱动最重要目标的达成。 \n \n \nIt shall pass too \n \n \nhow much free time do you have in a week: \n24 * 7 \n-56 sleep \n-40 a full-time job \n-14 eat \n-15 laioffer classes \n= 43 it’s more than another full time job \n \nIt’s a marathon, not a sprint \n \n《Grit: the power of passion and perseverance》 Angela Lee Duckworth \nhttps://www.youtube.com/watch?v=H14bBuluwB8 \n \nSelf caring \n \nClass 20: Practice Problems \nJava Generics \n \nRecall: What is the signature of the sorting algorithms you wrote? \n \nint[] sort(int[] array)  \n \nIt would be nice if we could write a single sort method that could sort the elements in an Integer \narray, a String array, or an array of any type that supports ordering. \n \nJava Generic methods and generic classes enable programmers to specify \n-with a single method declaration, a set of related methods, or \n-with a single class declaration, a set of related types. \n \nGeneric method Example \n \npackage laioffer; \n \npublic class Test { \n   // generic method printArray \n   public static <E> void printArray(E[] inputArray) { \n      // Display array elements \n      for(E element : inputArray) { \n         System.out.printf(\\\"%s \\\", element); \n      } \n      System.out.println(); \n   } \n \n   public static void main(String args[]) { \n      // Create arrays of Integer, Double and Character \n      Integer[] intArray = { 1, 2, 3, 4, 5 }; \n      Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 }; \n      Character[] charArray = { 'W', 'O', 'R', 'L', 'D' }; \n \n      System.out.println(\\\"Array integerArray contains:\\\"); \n      printArray(intArray);   // pass an Integer array \n \n      System.out.println(\\\"\\\nArray doubleArray contains:\\\"); \n      printArray(doubleArray);   // pass a Double array \n \n      System.out.println(\\\"\\\nArray characterArray contains:\\\"); \n      printArray(charArray);   // pass a Character array \n   } \n} \n \n1. Syntax \n \n<E> public static  void  printArray(E[] inputArray) { \npublic  <E>  static  void  printArray(E[] inputArray) { \npublic static  void  <E> printArray(E[] inputArray) { \npublic static  void  printArray<E>(E[] inputArray) { \npublic static  void  printArray(E[] inputArray) <E> { \n \nAll wrong \n \npublic static <E> void printArray(E[] inputArray) { \n \nRight \n \n2. Number of Generics \n \npackage laioffer; \nimport java.util.*; \n \npublic class Test { \n   public static <A, B, C> void printAll(A[] arr, List<B> list, Queue<C> \nqueue) { \n      for (A a : arr) { \n   System.out.print(a + \\\" \\\"); \n      } \n      System.out.println(\\\"\\\"); \n      for (int i = 0; i < list.size(); i++) { \n   B b = list.get(i); \n   System.out.print(b + \\\" \\\"); \n      } \n      System.out.println(\\\"\\\"); \n      while (!queue.isEmpty()) { \n   C c = queue.poll(); \n   System.out.print(c + \\\" \\\"); \n      } \n   } \n \n   public static void main(String args[]) { \n      Integer[] array = { 1, 2, 3 }; \n      List<Double> list = new ArrayList<>(); \n      list.add(1.5); list.add(2.5); list.add(3.5); \n      Queue<String> queue = new LinkedList<>(); \n      queue.offer(\\\"c\\\"); queue.offer(\\\"o\\\"); queue.offer(\\\"o\\\"); queue.offer(\\\"l\\\"); \n      printAll(array, list, queue); \n   } \n} \n \n3. Use cases \n \npackage laioffer; \nimport java.util.*; \n \npublic class Test { \n   public static <E> E findMiddle(E[] array) { \n      int mid = array.length / 2; \n      E midElem = array[mid]; \n      return midElem; \n   } \n \n   public static void main(String args[]) { \n      String[] array = {\\\"Adam\\\", \\\"Bob\\\", \\\"Cathy\\\"}; \n      String mid = findMiddle(array); \n      System.out.println(mid); \n   } \n} \n \n4. Object only \n \npackage laioffer; \nimport java.util.*; \n \npublic class Test { \n   public static <E> E findMiddle(E[] array) { \n      int mid = array.length / 2; \n      E midElem = array[mid]; \n      return midElem; \n   } \n \n   public static void main(String args[]) { \n      Integer[] array = {1, 3, 5}; \n      int mid = findMiddle(array); // unbox \n      System.out.println(mid); \n   } \n} \n \nThe method findMiddle(E[]) in the type Test is not applicable for the arguments (int[]) \n \nYou can write a single generic method declaration that can be called with arguments of \ndifferent types. Based on the types of the arguments passed to the generic method, the \ncompiler handles each method call appropriately. \n \n1.Syntax: All generic method declarations have a type parameter section delimited by \nangle brackets (< and >) that precedes the method's return type ( < E > in the next \nexample). \n2.Number of Generics: Each type parameter section contains one or more type \nparameters separated by commas. A type parameter, also known as a type variable, is \nan identifier that specifies a generic type name. \n3.Applicable Uses: The type parameters can be used to declare the return type and act \nas placeholders for the types of the arguments passed to the generic method \n4.Object only: A generic method's body is declared like that of any other method. Note that \ntype parameters can represent only reference types, not primitive types (like int, \ndouble and char). \n \nAdvanced Feature \n \nWhat if we want to write a generic method for finding the minimum of an array. \n \nAny problem? \n \npackage laioffer; \npublic class Test { \n   // generic method printArray \n   public static <E> E getMin(E[] arr) { \n      if (arr == null || arr.length == 0) { \n   return null; \n      } \n      E min = arr[0]; \n      for(int i = 1; i < arr.length; i++) { \n         min = arr[i] < min ? arr[i] : min; \n      } \n      return min; \n   } \n   public static void main(String args[]) { \n      // Create arrays of Integer, Double and Character \n      Integer[] intArray = { 1, 2, 3, 4, 5 }; \n      Integer m1 = getMin(intArray); \n      System.out.println(m1); \n  \n      Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 }; \n      Double m2 = getMin(doubleArray); \n      System.out.println(m2); \n  \n      Character[] charArray = { 'W', 'O', 'R', 'L', 'D' }; \n      Character m3 = getMin(charArray); \n      System.out.println(m3); \n   } \n} \n1) From a syntax point of view: E can be any object, < may not compile \n2) From a logical point of view: To find the minimum, E should be Comparable. If it is a random \nObject type, < may not make sense! \n \nWhat should we do? \n \npackage laioffer; \n \npublic class Test { \n   // generic method printArray \n   public static <E extends Comparable<E>> E getMin(E[] arr) { \n      if (arr == null || arr.length == 0) { \n   return null; \n      } \n      E min = arr[0]; \n      for(int i = 1; i < arr.length; i++) { \n         min = arr[i].compareTo(min) < 0 ? arr[i] : min; \n      } \n      return min; \n   } \n \n   public static void main(String args[]) { \n      // Create arrays of Integer, Double and Character \n      Integer[] intArray = { 1, 2, 3, 4, 5 }; \n      Integer m1 = getMin(intArray); \n      System.out.println(m1); \n  \n      Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 }; \n      Double m2 = getMin(doubleArray); \n      System.out.println(m2); \n  \n      Character[] charArray = { 'W', 'O', 'R', 'L', 'D' }; \n      Character m3 = getMin(charArray); \n      System.out.println(m3); \n   } \n} \n \n1.There may be times when you'll want to restrict the kinds of types that are allowed to be \npassed to a type parameter.  \n2.For example, a method that operates on numbers might only want to accept instances of \nNumber or its subclasses. This is what bounded type parameters are for. \n3.To declare a bounded type parameter, list the type parameter's name, followed by the \nextends keyword, followed by its upper bound. \n4.If we want to extends multiple interfaces/one class, we can do E extends Integer & \nComparable<E> & Iterable<E>, the class being extended needs to put at the beginning \n \nGeneric Class Example \n \nRecall: \n \nList<Integer> \nMap<String, Integer> \nPriorityQueue<GraphNode> \n \n \npackage laioffer; \n \npublic class Test { \n   public static void main(String args[]) { \n   Node<Integer> node = new Node<>(1); \n   System.out.println(node.toString()); \n   node.setValue(2); \n   int result = node.getValue(); // unboxing \n   } \n} \n \nclass Node<T> { \nprivate T value; \npublic Node(T v) { \nvalue = v; \n} \npublic String toString() { \nreturn value.toString(); \n} \nPublic T getValue() { \nT result = value; \nreturn result; \n} \npublic void setValue(T v) { \nvalue = v; \n} \n} \n \nSummary: \n1.Syntax: after class name, before \\\"{\\\" \n2.Usage: can be used anywhere in the class \na.member variable \nb.method parameter \nc.method return type \nd.method local variable \n3.Only the class needs to be parameterized: its method function does not need <T> \nanymore \n4.When you create object \na.Node<Integer> node = new Node<>(1); \nb.Node<Integer> node = new Node(1); is not good (warning) (just like ArrayList) \n \nExample: 比较二元对 \n \npublic class MyPair<K, V> { \n \n    private K key; \n    private V value; \n \n    public MyPair(K key, V value) { \n        this.key = key; \n        this.value = value; \n    } \n \n    @Override \n    public String toString() { \n        return \\\"MyPair [key=\\\" + key + \\\", value=\\\" + value + \\\"]\\\"; \n    } \n \n    public void setKey(K key) { this.key = key; } \n    public void setValue(V value) { this.value = value; } \n    public K getKey()   { return key; } \n    public V getValue() { return value; } \n} \n \npublic class Util { \n    public static <K, V> boolean myequal(MyPair<K, V> p1,  \n                                         MyPair<K, V> p2) { \n        return p1.getKey().equals(p2.getKey()) && \n               p1.getValue().equals(p2.getValue()); \n    } \n} \n \npublic class GenericMethod2 { \npublic static void main(String args[]) { \nMyPair<String, Integer> p1 = new MyPair<>(\\\"a\\\", 1); \nMyPair<String, Integer> p2 = new MyPair<String, Integer>(\\\"b\\\", 2); \nMyPair<String, Integer> p3 = new MyPair<>(\\\"a\\\", 1); \n \nSystem.out.println(p1 + \\\" compares with \\\" + p2 + \\\" : \\\" +  \n   Util.myequal(p1, p2)); \nSystem.out.println(p1 + \\\" compares with \\\" + p3 + \\\" : \\\" +  \n   Util.<String, Integer>myequal(p1, p3)); \n \n} \n} \n \n阅读内容： \nJava 泛型实现原理 : 类型擦除保留原始类型 (Type Erasure) \n \npublic class Test { \n// generic method printArray \npublic static <E> void  printArray(E[] inputArray) { \n// Display array elements \nfor(E element : inputArray) { \nSystem.out.printf(\\\"%s \\\", element); \n} \nSystem.out.println(); \n} \n} \n \n相当于 \n \npublic class Test { \n// generic method printArray \npublic static void printArray(Object[] inputArray) { \n// Display array elements \nfor(Object element : inputArray) { \nSystem.out.printf(\\\"%s \\\", element); \n} \nSystem.out.println(); \n} \n} \n \n如果有泛型类型限定 \npublic class Test { \n// generic method printArray \npublic static <E extends Comparable<E>>  \nvoid  printArray(E[] inputArray) { \n… \n} \n \n相当于 \n \npublic class Test { \n// generic method printArray \npublic static void  printArray(Comparable[] inputArray) { \n// Display array elements \nfor(Comparable element : inputArray) { \nSystem.out.printf(\\\"%s \\\", element); \n} \nSystem.out.println(); \n} \n} \n \n一个验证程序： \n \npublic class genericTypeErasure { \npublic static void main(String[] args) { \nArrayList<Integer> a1 = new ArrayList<Integer>(); \nArrayList<String> a2 = new ArrayList<String>(); \nClass c1 = a1.getClass(); \nClass c2 = a2.getClass(); \nSystem.out.println(c1==c2); // 判定两个类型相同 \nSystem.out.println(c1); // class java.util.ArrayList \ntry { \na2.getClass() \n                 .getMethod(\\\"add\\\", Object.class) \n                 .invoke(a2, \\\"a\\\"); // 成功将字符串对象插入整数数组 \nSystem.out.println(a2.size()); \n} catch (Throwable e) { \ne.printStackTrace(); \n} \n} \n} \n \n从类型擦除可以看出： \n1)必须是Object继承的类型作为泛型类型，不然没法转成Object \n2)runtime只能看到原始类型，如上例只有ArrayList类型 \n3)新建一个泛型类指定的对象是不可以的，比如： \nK tmp = new K(); \n4)编译器自动加入类型的强制转换，比如： \nArrayList<Employee> emps = …; \nEmployee e = (Employee) emps.get(0);  -> 先获取Object对象，再类型转换成\nEmployee \n \nSubclass and Superclass in Generics \nRemember that: \nApple apple = new Apple(); \nFruit fruit = apple; // ok since Apple IS-A Fruit \n \n// what if \nFruit fruit = new Fruit(); \nApple apple = fruit; // wrong, need casting \nApple apple2 = (Apple) fruit; // can compile, but if fruit is not actually \nApple than will have ClassCastException at runtime \n \nA subclass can always be casted to a superclass but not the other way. \n \nIn Generics, it’s different: \nList<Apple> apples = new ArrayList<>(); \nList<Fruit> fruits = apples; // not allowed, compiled error \n \nfruits.add(new Apple()); // ok. \nfruits.add(new Orange()); // ok. \n \nIf you allow fruits = apples, then we may do fruits.add(new Orange()), but Orange is not Apple. \n \nGenerics check the type during compile-time. In contrast, Array doesn’t. \nApple[] apples = new Apple[3]; \nFruit[] fruits = apples; // ok at compile time \nfruits[0] = new Apple(); // ok \nfruits[1] = new Fruit(); // ArrayStoreException. A Fruit object is not \nnecessarily an Apple object \nfruits[2] = new Orange(); // ArrayStoreException \n \nSo it’s not allowed to include types of a super/sub class when working with generic references? \nWe may use <? Extends T> or <? Super T> \n \n通配符的使用 (Wildcard) \n \n? extends (Upper Bounded Wildcard) \n \nList<Apple> apples = new ArrayList<>(); \nList<? extends Fruit> fruits = apples; // ok \nList<Orange> oranges = new ArrayList<>(); \nfruits = oranges; // ok \nFruit fruit = fruits.get(0); // read is fine \nApple apple = (Apple) fruits.get(0); \nfruits.add(new Apple()); // compile error \nfruits.add(new Fruit()); // compile error, actually, you cannot add \nanything to fruits \n \nWhy? fruits is a list of objects that extend from Fruit (can be list of Fruit, list of Apple, list of \nOrange, etc), and it’s actually a list of Apple. To add a new object to it we are not sure whether it \nis Apple, Orange, etc, or not. It only gives you read-time flexibility. \n \n? super (Lower Bounded Wildcard) \n \nList<Fruit> fruits = new ArrayList<>(); \nList<? super Apple> apples = fruits; \napples.add(new Apple()); // because apples can be a list of Apple, so can \nonly add Apple or its subclass \napples.add(new GreenApple()); \napples.add(new Fruit()); // compile error \napples.add((Apple) (new Fruit())); // compile time ok, runtime error \napples.add(new Orange()); // compile time error \nFruit fruit = apples.get(0); // compile time error, apples.get(0) can be \nanything super to Apple, including Object \nFruit fruit2 = (Fruit) apples.get(0); // ok \nWhy? It can be a list of Apple, list of Fruit, list of Object. It only knows apples is a list of objects \nthat are superclass of Apple, but not which superclass in the inheritance tree. \n \nConclusion: To get data use <? extends>, to write data use <? super> \n \n \n问题： \npublic static <T extends Comparable<? super T>>  \nvoid sort(List<T> list)  什么意思 \n \nT 类型必须是继承了Comparable接口的，这个接口还必须是泛型类型为T或者T的超类的。这\n样Comparable接口就是对T有效的，也就是可用于比较T类型对象的。 \n \npublic class Wildcard { \n  public static void main(String args[]) { \n     sort(new ArrayList<Apple>()); \n  } \n \n  // Generic method \n  public static <T extends Comparable<? super T>> void sort(List<T> \nlist) { \n     // need to use compareTo() \n  } \n \n  static class Fruit implements Comparable<Fruit> { \n     @Override \n     public int compareTo(Fruit o) { \n        return 0; \n     } \n  } \n  \n  static class Apple extends Fruit { \n  } \n} \n \n \n泛型类型与通配符使用比较 \n泛型类型：有个类型叫T, 可以用T干很多事情 \n通配符：我不知道的一个类型，不能直接用？，需要类型捕获之后用 \n \n1) 有时候是看起来功能是一样的 \n \npublic boolean containsAll(Collection<?> c); \npublic boolean addAll(Collection<? extends E> c); \n \nVS \n \npublic <T> boolean containsAll(Collection<T> c); \npublic <T extends E> boolean addAll(Collection<T> c); \n \n2) 有时候不行 （必须用泛型类型） \npublic static <T extends Number>  \nvoid copy(List<T> dest, List<T> src); \n和下列写法不等 \npublic static  \nvoid copy(List<? extends Number> dest,  \nList<? extends Number> src); \n \n无法约束dest和src间类型一致的要求。 \n \n另一个例子(demo) \npublic static boolean fun(List<?> list) { \nreturn list.add(list.remove(0)); \n} \n \n编译不过，不能保证remove得到的对象类型和list的期待类型一致。 \n \npublic static void func2(List<?> list, Object something) { \nlist.add(something); \n} \n \n插入的Object不能保证和？匹配 \n \n3) 多类型约束 （必须用泛型类型） \n不能写 <? extends X & Y> \n \n4) 有时候不行 （必须用通配符） \n用Lower Bounded Wildcard的时候。不能写<T super X> \n \nBasic Java File Read/Write \nThe java.io package contains nearly every class you might ever need to perform input and \noutput (I/O) in Java. All these streams represent an input source and an output destination. The \nstream in the java.io package supports many data such as primitives, objects, localized \ncharacters, etc. \n \nStream \nA stream can be defined as a sequence of data. \n \nInputStream − The InputStream is used to read data from a source. \nOutputStream − The OutputStream is used for writing data to a destination. \n \nByte Streams \n \nJava byte streams are used to perform input and output of 8-bit byte. Though there are many \nclasses related to byte streams, the most frequently used classes are FileInputStream and \nFileOutputStream.  \n \nModifier and Type \n\t\nMethod and Description \n\n\nint \n\t\navailable() \nReturns an estimate of the number of remaining bytes that can be read (or skipped \nover) from this input stream without blocking by the next invocation of a method for \nthis input stream. \n\n\nvoid \n\t\nclose() \nCloses this file input stream and releases any system resources associated with the \nstream. \n\n\nint \n\t\nread() \nReads a byte of data from this input stream. \n\n\nint \n\t\nread(byte[] b) \nReads up to b.length bytes of data from this input stream into an array of bytes. \n\n\nint \n\t\nread(byte[] b, int off, int len) \nReads up to len bytes of data from this input stream into an array of bytes. \n\n\nlong \n\t\nskip(long n) \n\t\nSkips over and discards n bytes of data from the input stream. \n \n \n \nExample \n \npackage laioffer; \nimport java.io.*; \npublic class Test { \npublic static void main(String args[]) throws IOException {  \nFileInputStream in = null; \nFileOutputStream out = null; \ntry { \nin = new \nFileInputStream(\\\"/Users/Shared/workspace/testdata/input.txt\\\"); \n// Hi! \n// How are you? \n// What are you doing? \nout = new \nFileOutputStream(\\\"/Users/Shared/workspace/testdata/output.txt\\\"); \nint c; \nwhile ((c = in.read()) != -1) { \nSystem.out.print((char)c); \nout.write(c); \n} \n} finally { \nif (in != null) { \nin.close(); \n} \nif (out != null) { \nout.close(); \n} \n} \n} \n} \n \nUsing read(byte[] bytes) API \npackage laioffer; \nimport java.io.*; \npublic class Test { \npublic static void main(String args[]) throws IOException {  \nFileInputStream in = null; \ntry { \nin = new \nFileInputStream(\\\"/Users/Shared/workspace/testdata/input.txt\\\"); \n// Hi! \n// How are you? \n// What are you doing? \nbyte[] bytes = new byte[7]; \nint n = in.read(bytes); \nSystem.out.println(\\\"n = \\\" + n); \nfor (int i = 0; i < n; i++) { \nSystem.out.print((char)bytes[i]); \n} \n} finally { \nif (in != null) { \nin.close(); \n} \n} \n} \n} \n \nWhy \\\"try... finally...\\\"? \n \npackage laioffer; \nimport java.io.*; \npublic class Test { \npublic static void main(String args[]) throws IOException {  \nFileInputStream in = null; \ntry { \nin = new \nFileInputStream(\\\"/Users/Shared/workspace/testdata/nonexisting.txt\\\"); \n// Hi! \n// How are you? \n// What are you doing? \nbyte[] bytes = new byte[7]; \nint n = in.read(bytes); \nSystem.out.println(\\\"n = \\\" + n); \nfor (byte b : bytes) { \nSystem.out.print((char)b); \n} \n} finally { \nif (in != null) { \nin.close(); \n} \n} \n} \n} \n \nException in thread \\\"main\\\" java.io.FileNotFoundException: \n/Users/Shared/workspace/testdata/xinput.txt (No such file or directory) \nat java.io.FileInputStream.open0(Native Method) \nat java.io.FileInputStream.open(FileInputStream.java:195) \nat java.io.FileInputStream.<init>(FileInputStream.java:138) \nat java.io.FileInputStream.<init>(FileInputStream.java:93) \nat laioffer.Test.main(Test.java:8) \n \n \npackage laioffer; \nimport java.io.*; \npublic class Test { \npublic static void main(String args[]) throws IOException {  \nFileInputStream in = null; \nFileOutputStream out = null; \ntry { \nin = new \nFileInputStream(\\\"/Users/Shared/workspace/testdata/input.txt\\\"); \n// Hi! \n// How are you? \n// What are you doing? \nbyte[] bytes = new byte[10]; \nint n = in.read(bytes, 0, 20); \nSystem.out.println(\\\"n = \\\" + n); \nfor (byte b : bytes) { \nSystem.out.print((char)b); \n} \n} finally { \nif (in != null) { \nin.close(); \n} \n} \n} \n} \n \nException in thread \\\"main\\\" java.lang.IndexOutOfBoundsException \nat java.io.FileInputStream.readBytes(Native Method) \nat java.io.FileInputStream.read(FileInputStream.java:255) \nat laioffer.Test.main(Test.java:13) \n \nNote: \n1.Exceptions of different types can be thrown.  \n2.File close must be done in \\\"finally\\\", to make sure files can be closed no matter \nwhat exceptions can happen. \n \nCharacter streams \n \nCharacter streams are used to perform input and output for 16-bit unicode. Though there are \nmany classes related to character streams, the most frequently used classes are FileReader \nand FileWriter. Though internally FileReader uses FileInputStream and FileWriter uses \nFileOutputStream but here the major difference is that FileReader reads two bytes at a time and \nFileWriter writes two bytes at a time. \n \nWe can re-write the above example, which makes the use of these two classes to copy an input \nfile (having unicode characters) into an output file − \n \npackage laioffer; \nimport java.io.*; \npublic class Test { \npublic static void main(String args[]) throws IOException {  \nFileReader in = null; \nFileWriter out = null; \ntry { \nin = new \nFileReader(\\\"/Users/Shared/workspace/testdata/chineseinput.txt\\\"); \n// 问我这几年的日子可滋润， \n// 问我可有一个漂亮的姑娘在爱着， \n// 问我现在成了大牛倌放多少头牛 \nout = new \nFileWriter(\\\"/Users/Shared/workspace/testdata/chineseoutput.txt\\\"); \nint c; \nwhile ((c = in.read()) != -1) { \nSystem.out.print((char)c); \nout.write(c); \n} \n} finally { \nif (in != null) { \nin.close(); \n} \nif (out != null) { \nout.close(); \n} \n} \n} \n} \n \nTry what will happen if we use 8-bit FileInputStream? \n \npackage laioffer; \nimport java.io.*; \npublic class Test { \npublic static void main(String args[]) throws IOException {  \nFileInputStream in = null; \nFileOutputStream out = null; \ntry { \nin = new \nFileInputStream(\\\"/Users/Shared/workspace/testdata/chineseinput.txt\\\"); \n// 问我这几年的日子可滋润， \n// 问我可有一个漂亮的姑娘在爱着， \n// 问我现在成了大牛倌放多少头牛 \nout = new \nFileOutputStream(\\\"/Users/Shared/workspace/testdata/chineseoutput.txt\\\")\n; \nint c; \nwhile ((c = in.read()) != -1) { \nSystem.out.print((char)c); \nout.write(c); \n} \n} finally { \nif (in != null) { \nin.close(); \n} \nif (out != null) { \nout.close(); \n} \n} \n} \n} \n \nStandard Streams \n \nAll the programming languages provide support for standard I/O where the user's program can \ntake input from a keyboard and then produce an output on the computer screen. Java provides \nthe following three standard streams − \n \n \n \nStandard Input − This is used to feed the data to user's program and usually a keyboard is used \nas standard input stream and represented as System.in. \n \nStandard Output − This is used to output the data produced by the user's program and usually a \ncomputer screen is used for standard output stream and represented as System.out. \n \nStandard Error − This is used to output the error data produced by the user's program and \nusually a computer screen is used for standard error stream and represented as \nSystem.err. \n \npackage laioffer; \nimport java.io.*; \npublic class Test { \n   public static void main(String args[]) throws IOException { \n      InputStreamReader cin = null; \n      try { \n         cin = new InputStreamReader(System.in); \n         System.out.println(\\\"Enter characters, 'q' to quit.\\\"); \n         StringBuilder userInput = new StringBuilder(); \n         while (true) { \n  char c = (char) cin.read(); \n  if (c == 'q') { \n  break; \n  } \n  userInput.append(c); \n         } \n         System.out.println(userInput); \n      }finally { \n         if (cin != null) { \n            cin.close(); \n         } \n      } \n   } \n} \n \nNote: \n1.We are reading byte by byte; \n2.The input byte is converted to char \n3.We use a special character to represent \\\"stop\\\" condition. \n \n \n可不可以讲下怎么从文件里面读取数据，和输出数据，比如我把一堆test case 写到text里面，\n跑完把结果输出到text 然后我再检查结果是不是正确，而不是每次都是print出来。 \n \n \n如果只是为了做test，建议使用main函数或者JUnit。不太建议把test case存到file里。 \nCommon Java Read/Write Operations \nThe above streams all handle input / output byte by byte. \n \nIt is more natural and easy to understand if we can handle input / output line by line. \n \npackage laioffer; \nimport java.io.*; \npublic class Test { \npublic static void main(String args[]) throws IOException { \nFileInputStream fis = new \nFileInputStream(\\\"/Users/Shared/workspace/testdata/input.txt\\\"); \n \n//Construct BufferedReader from InputStreamReader \nBufferedReader br = new BufferedReader(new \nInputStreamReader(fis)); \n \nString line = null; \nwhile ((line = br.readLine()) != null) { \nSystem.out.println(line); \n} \n \nbr.close(); \n} \n} \n \nNote: \n1.You still need to first create FileInputStream \n2.You can construct BufferedReader on top of the FileInputStream \n3.BufferedReader supports operations like \\\"readLine\\\" which handles data line by line. \n \n \nModifier and Type \n\t\nMethod and Description \n\n\nvoid \n\t\nclose() \nCloses the stream and releases any system resources associated with it. \n\n\nvoid \n\t\nmark(int readAheadLimit) \nMarks the present position in the stream. \n\n\nboolean \n\t\nmarkSupported() \n\t\nTells whether this stream supports the mark() operation, which it does. \n\n\nint \n\t\nread() \nReads a single character. \n\n\nint \n\t\nread(char[] cbuf, int off, int len) \nReads characters into a portion of an array. \n\n\nString \n\t\nreadLine() \nReads a line of text. \n\n\nboolean \n\t\nready() \nTells whether this stream is ready to be read. \n\n\nvoid \n\t\nreset() \nResets the stream to the most recent mark. \n\n\nlong \n\t\nskip(long n) \nSkips characters. \n \n \n老师，想用java来读文件，google了一下，写了一个java读取txt文件的句子， \nBufferedReader br = new BufferedReader(“/Users/test.txt\\\"); \n但好像并不能运行，说是找不到文件， 我输入的就是文件的路径。然后该import的也import\n了。不知道到底是怎么回事。 \n \n想请问一下java 读取文件的具体操作该怎么做。 \nBufferedReader can be constructed with InputStreamReader, but not string (filename)! \n \n \nHow is BufferedReader implemented? It is a common algorithm question. \n \nclass MyBufferedReader { \npublic MyBufferedReader(FileInputStream in) { \n} \npublic String nextLine() { \n} \n} \n \nSolution: \n \npackage laioffer; \nimport java.io.*; \npublic class Test { \npublic static void main(String args[]) throws IOException { \nFileInputStream input = null; \ntry { \ninput = new \nFileInputStream(\\\"/Users/Shared/workspace/testdata/input.txt\\\"); \nMyBufferedReader myReader = new \nMyBufferedReader(input); \nString line1 = myReader.nextLine(); \nSystem.out.println(line1); \n} finally { \ninput.close(); \n} \n} \n} \n \nclass MyBufferedReader { \nprivate FileInputStream in; \nprivate StringBuilder buffer; \npublic MyBufferedReader(FileInputStream in) { \nthis.in = in; \nbuffer = new StringBuilder(); \n} \npublic String nextLine() throws IOException { \nwhile (true) { \nint c = in.read(); \nif (c == -1 || c == '\\\n') { \nbreak; \n} \nbuffer.append((char)c); \n} \nString output = buffer.toString(); \nbuffer = new StringBuilder(); \nreturn output; \n} \n} \n \nLet's take a look at standard input then: \n \npackage laioffer; \nimport java.util.Scanner; \npublic class Test { \n@SuppressWarnings(\\\"resource\\\") \npublic static void main(String args[]) { \nScanner scanner = new Scanner(System.in); \nSystem.out.println(\\\"Please type: \\\"); \nwhile (true) { \nString line = scanner.nextLine(); \nif (line.toLowerCase().equals(\\\"exit\\\")) { \nbreak; \n} \nSystem.out.println(\\\"Input text: \\\" + line); \n} \n} \n} \n \nhttps://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html \nhttps://docs.oracle.com/javase/7/docs/api/java/lang/System.html \nhttps://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html \n \nDirectories \n \n1.A directory is a File which can contain a list of other files and directories.  \n2.You use File object to create directories, to list down files available in a directory. \n \nCreating Directories \nThere are two useful File utility methods, which can be used to create directories − \n●The mkdir( ) method creates a directory, returning true on success and false on failure. \nFailure indicates that the path specified in the File object already exists, or that the \ndirectory cannot be created because the entire path does not exist yet. (similar to linux $ \nmkdir) \n●The mkdirs() method creates both a directory and all the parents of the directory. \n(similar to linux $ mkdir -p) \n \npackage laioffer; \nimport java.io.*; \npublic class Test { \npublic static void main(String args[]) throws IOException { \nString dirname = \n\\\"/Users/Shared/workspace/testdata/testdir\\\"; \n      File d = new File(dirname); \n  \n      // Create directory now. \n      d.mkdirs(); \n} \n} \n \nYou can use list( ) method provided by File object to list down all the files and directories \navailable in a directory as follows  \npackage laioffer; \nimport java.io.*; \npublic class Test { \npublic static void main(String args[]) throws IOException { \nString dirname = \\\"/Users/Shared/workspace/testdata/\\\"; \nFile d = new File(dirname); \n// Create directory now. \nString[] paths = d.list(); \nfor (String p : paths) { \nSystem.out.println(p); \n} \n} \n} \n \n[\\\"/Users/Shared/workspace/testdata/abc\\\", \n\\\"/Users/Shared/workspace/testdata/test.txt\\\"] \n \n《高效能人士的执行4原则》\nIt shall pass too\nIt’s a marathon, not a sprint\nClass 20: Practice Problems\nJava Generics\nGeneric method Example\npublic static <E> void printArray(E[] inputArray) {\n3. Use cases\n4. Object only\nThe method findMiddle(E[]) in the type Test is not applicable for the arguments (int[])\nAdvanced Feature\nGeneric Class Example\nExample: 比较二元对\nJava 泛型实现原理 : 类型擦除保留原始类型 (Type Erasure)\n相当于\n一个验证程序：\n从类型擦除可以看出：\nSubclass and Superclass in Generics\n? super (Lower Bounded Wildcard)\n1) 有时候是看起来功能是一样的\n2) 有时候不行 （必须用泛型类型）\n另一个例子(demo)\n编译不过，不能保证remove得到的对象类型和list的期待类型一致。\n3) 多类型约束 （必须用泛型类型）\n4) 有时候不行 （必须用通配符）\nBasic Java File Read/Write\nUsing read(byte[] bytes) API\nWhy \\\"try... finally...\\\"?\nCharacter streams\nTry what will happen if we use 8-bit FileInputStream?\nStandard Streams\nCommon Java Read/Write Operations\nLet's take a look at standard input then:\nDirectories\nTurn on screen reader support\"";
        System.out.println(str);
    }
}
